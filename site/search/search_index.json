{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Numerical Methods in MATLAB","text":""},{"location":"Approximation/Interpolation/","title":"Interpolation using polyval and polyfit","text":""},{"location":"Approximation/Interpolation/#polyval-and-polyfit","title":"Polyval and Polyfit","text":"<p>To interpolate a function f(x) over an interval (-2, 4) in 7 nodes, first, we need to define the 7 nodes belonging to the x-axis</p> <pre><code>n_nodes = 7; % just specifying at the beginning the number of nodes\nx_nodes = linspace(-2, 4, 7)\n</code></pre> <p>Secondly, we need to compute the f(x) in these seven nodes, calling the vector y</p> <pre><code>y_nodes = f(x_nodes)\n</code></pre> <p>Ultimately, with <code>polyfit</code> we compute the coefficients of these polynomials, as a vector. We only need the coefficients to discriminate a single polynomial form</p> <pre><code>p_coeffs = polyfit(x_nodes, y_nodes, n_nodes - 1)\n</code></pre> <p>Now, I can evaluate the polynomial either over an interval or a point</p> <ul> <li>over an interval z</li> </ul> <pre><code>z = linspace(-2, 4, 1000); % I want the interval to be dense of points\np = polyval(p_coeffs, z);\n</code></pre> <ul> <li>over a point</li> </ul> <pre><code>p = polyval(p_coeffs, 0.75);\n</code></pre>"},{"location":"Approximation/Interpolation/#error-estimation","title":"Error estimation","text":"<p>There are ways to compute the error, whether relative or absolute</p>"},{"location":"Approximation/Splines/","title":"Splines","text":""},{"location":"Approximation/Splines/#linear-splines","title":"Linear Splines","text":"<p>I pass the set of data (xi, yi) and the interval where I want to compute the linear spline</p> <pre><code>f = @(x)\ns = interp1(x,y,z)\n</code></pre>"},{"location":"Approximation/Splines/#cubic-splines","title":"Cubic Splines","text":""},{"location":"Approximation/Splines/#not-a-knot","title":"Not-a-knot","text":""},{"location":"Approximation/Splines/#vincolate","title":"Vincolate","text":""},{"location":"Integrals/IntegralsGeneral/","title":"General Method for Solving Integrals in MATLAB","text":"<p>The easiest way to compute an integral</p> <pre><code>format short e\n\n% Define your function\nf = @(x) x.^2 + sin(x);\n\n% Compute the integral from a to b\na = 0;      % Lower limit\nb = pi;     % Upper limit\n\nI = integral(f, a, b);\nI\n</code></pre>"},{"location":"Matrices/BuildingMatrices/","title":"Building Mats","text":""},{"location":"Matrices/BuildingMatrices/#basic-vectors","title":"Basic Vectors","text":"<p>Column vector of 4s</p> <pre><code>d = 4*ones(4, 1)\n</code></pre> <pre><code>d =\n\n   4\n   4\n   4\n   4\n</code></pre> <p>We can transpose it, turning it into a row vector</p> <pre><code>d = 4*ones(4, 1)'\n</code></pre> <pre><code>d =\n\n   4   4   4   4\n</code></pre>"},{"location":"Matrices/BuildingMatrices/#putting-vectors-into-matrices-diagonally","title":"Putting vectors into matrices, diagonally","text":"<p>This is how you put a vector in the diagonal of a matrix</p> <pre><code>diag(ones(1,4), 0)\n</code></pre> <p>so that..</p> <pre><code>ans =\n\nDiagonal Matrix\n\n   1   0   0   0\n   0   1   0   0\n   0   0   1   0\n   0   0   0   1\n</code></pre> <p>Putting the vector in the superdiagonal directly above the elements comprising the diagonal  </p> <pre><code>diag(ones(1,4),1)\n</code></pre> <pre><code>ans =\n\n   0   1   0   0   0\n   0   0   1   0   0\n   0   0   0   1   0\n   0   0   0   0   1\n   0   0   0   0   0\n</code></pre> <p>and Subdiagonal, i.e. directly below ..</p> <pre><code>diag(ones(1,4),-1)\n</code></pre> <pre><code>ans =\n\n   0   0   0   0   0\n   1   0   0   0   0\n   0   1   0   0   0\n   0   0   1   0   0\n   0   0   0   1   0\n</code></pre> <p>Now, building a typical matrix:</p> <pre><code>A = -2*eye(5) + diag(ones(1,4),1) + diag(ones(1,4),-1);\n</code></pre> <pre><code>A =\n\n  -2   1   0   0   0\n   1  -2   1   0   0\n   0   1  -2   1   0\n   0   0   1  -2   1\n   0   0   0   1  -2\n</code></pre> <p><code>eye(n)</code> creates an Identity matrix of order <code>n</code></p>"},{"location":"Matrices/BuildingMatrices/#algorithm-for-the-anti-diagonal","title":"Algorithm for the Anti-Diagonal","text":"<p>To build an anti-diagonal matrix</p> <pre><code>% The anti-diagonal matrix\n\nn = 4;\nC = eye(n);\ntmp = zeros(n, 1);\n\nfor i = 1:n/2\n    tmp = C(:, i);\n    C(:, i) = C(:, n-i+1);\n    C(:, n-i+1) = tmp;\nend\n\n% to show it ..\nC\n</code></pre> <pre><code>C =\n\n   0   0   0   1\n   0   0   1   0\n   0   1   0   0\n   1   0   0   0\n</code></pre>"},{"location":"Matrices/BuildingMatrices/#composing-matrices","title":"Composing Matrices","text":"<p>This combines the matrices into a bigger one</p> <pre><code>A = [B, C; C, D]\n</code></pre> <p>of course, try to avoid dimensions mismatch</p>"},{"location":"Matrices/Factorizations/","title":"Factorizations","text":""},{"location":"Matrices/Factorizations/#lu","title":"LU","text":""},{"location":"Matrices/Factorizations/#choleski","title":"Choleski","text":""},{"location":"Matrices/Factorizations/#svd","title":"SVD","text":""},{"location":"Matrices/Gauss_Seidel/","title":"Gauss Seidel","text":"<p>With Gauss-Seidel the matrix A gets transformed with <code>tril(A)</code>. We require a lower triagonal matrix.</p> <pre><code>% Cleaning and choosing the number format\nformat short e\nclear all\nclose all\nclc\n</code></pre> <pre><code>% Building the matrix and the `Ax=b` system\nn = 18;\nA = 6*eye(n) + diag(-1*ones(n-1,1), 1) + diag(-1*ones(n-1,1), -1);\nb = A*ones(n, 1);\nx = zeros(n,1);\n</code></pre> <p>Preparing the <code>C</code> and <code>D</code> matrices used in the iterative method</p> <pre><code>D = tril(A);\nC = A - D;\n</code></pre> <pre><code>for k = 1:5\n    x = D\\(b-C*x);\nend\nerr = norm(ones(n,1)-x)/norm(ones(n,1))\n</code></pre>"},{"location":"Matrices/Gauss_Seidel/#gauss-seidel-with-residual-vector-check","title":"Gauss-Seidel with residual vector check","text":"<pre><code>% Gauss-Seidel with residual vector check (6-23)\n\nn = 20;\nA = 5*eye(n) + diag(-1*ones(n-1, 1), -1) + diag(-7*ones(n-2, 1), 2);\nb = A*ones(n, 1);\nx = zeros(n, 1);\n% Preparing the iteration matrix\nD = tril(A);\nC = A - D;\n% Starting Flag set to false\nflag = false;\n% the starting point of the residual vector\nr = b-A*x;\niterata = 0;\n\nwhile ~flag\n    % Gauss-Seidel Method\n    x = D\\(b-C*x); \n    r = b-A*x;\n    if norm(r, 2) &lt; 10^-3\n        flag = true;\n    end\n    iterata = iterata + 1;\nend\n</code></pre>"},{"location":"Matrices/Gradient/","title":"Gradient Descent","text":""},{"location":"Matrices/Gradient/#steepest-descent","title":"Steepest Descent","text":"<p>When implementing a gradient-based method (or performing any linear algebra computations related to a system like \ud835\udc34\ud835\udc65 = \ud835\udc4f) you want to use matrix multiplication (using <code>*</code>) rather than elementwise multiplication (<code>.*</code>).</p> <pre><code>B = magic(n);\nA = B'*B;\nb = sum(A,2);\n</code></pre> <p>The initial vector <code>x</code> and the initial residual vector <code>r</code></p> <pre><code>x = (1:5)';\nr = b-A*x;\n</code></pre> <p>The gradient descent method</p> <pre><code>for m = 1:30\n    a = (r'*r)/(r'*A*r);\n    x = x+a*r;\n    r = b-A*x;\nend\n</code></pre> <p>Say you want to compute the absolute error in <code>norm-2</code>, since we stated that the solution is the ones vector</p> <pre><code>err = norm(ones(n,1)-x)\n</code></pre>"},{"location":"Matrices/Gradient/#conjugate-gradient-without-preconditioning-implemented-natively-in-matlab","title":"Conjugate gradient without preconditioning, implemented natively in MATLAB","text":"<pre><code>% Setting up the computation\nclear all\nclose all\nformat short e\n</code></pre> <pre><code>% Setting up the matrices\nn = 2000;\nA = 5* eye(n) + diag(2*ones(n-5,1), 5) + diag(2*ones(n-5,1),-5);\nb = ones(n,1);\n</code></pre> <p>MATLAB\u2019s pcg function stands for <code>Preconditioned Conjugate Gradient</code>.</p> <pre><code>[x,FLAG,RELRES,ITER] = pcg(A,b)\n</code></pre> <p>Let's go over the details of the output <code>[x, FLAG, RELRES, ITER]</code>: - <code>x</code>: is the solution of <code>Ax=b</code>. - <code>FLAG</code>: A convergence flag. A flag of 0 typically indicates that the algorithm has converged successfully. - <code>RELRES</code>: The relative residual, which provides a measure of the accuracy of the computed solution. - <code>ITER</code>: The number of iterations the algorithm took to converge.</p>"},{"location":"Matrices/Gradient/#note-why-use-a-ones-vector","title":"Note: Why Use a Ones Vector?","text":"<p>Simplicity and Clarity - By choosing a vector of ones, the system is set up in a simple, easily understandable way. This makes it straightforward to analyze the behavior of the algorithm without the complications that might arise from a more complex or random right-hand side.</p> <p>Benchmarking the Algorithm - When testing or demonstrating the conjugate gradient method, using a uniform vector like this allows you to see how the algorithm converges on a known and controlled problem. It helps in evaluating the performance and accuracy of the method.</p> <p>Consistency - In many numerical experiments, especially in educational settings or initial testing, a ones vector is commonly used. This is because it provides a consistent and repeatable scenario for comparing the iterative solution with theoretical expectations.</p> <p>Numerical Stability - A right-hand side with all ones avoids introducing additional scale issues or numerical instabilities that might occur with more varied entries. This ensures that any observed behavior in the convergence of the algorithm is more likely due to the properties of \ud835\udc34. A and the method itself, rather than an artifact of the vector \ud835\udc4f.</p>"},{"location":"Matrices/Jacobi/","title":"Jacobi","text":"<pre><code>% Jacobi\nclear all\nclose all\nclc\nn = 20;\nA = 5* eye(n) + diag(-1*ones(n-1,1), -1) + diag(-7*ones(n-2,1),2);\nb = A * ones(n,1);\nx = zeros(n,1); % Pre-allocation, and also we built it this way\nD = diag(diag(A));\nC = A - D;\ntol = 1.0e-3;\nfor k = 1:1000\n    x = D\\(b-C*x);\n    if norm(b - A*x ,2)/norm(b, 2) &lt; tol\n        break\n    end\nend\nk\n</code></pre> <pre><code>% % Jacobi\n% clear all\n% close all\n% clc\n% n = 10;\n% A = 10* eye(n) + diag(3*ones(7,1), 3) + diag(-5*ones(5,1),-5);\n% b = A * ones(n,1);\n% x = (1:10)';\n% D = diag(diag(A));\n% C = A - D;\n% tol = 1.0e-10;\n% for k = 1:1000\n    % x = D\\(b-C*x);    \n    % if norm(b - A*x ,2) &lt; tol*norm(b, 2)\n        % break\n    % end\n% end\n% k\n\n\n% Jacobi 9/15\n\nn = 100;\nA = 3*eye(n) + diag(ones(n-1, 1), -1) + diag(ones(n-1, 1), + 1);\n\nsol = ones(n, 1);\nb = A*sol;\n\nD = diag(diag(A));\nC = A - D;\n\nx0 = linspace(0, 1, 20);\n\nfor i = 1:20\n    x0 = D\\(b-C*x);\n    x = x0;\nend\n\nerr = norm(abs(x - x0), inf);\n\nfprintf('The result is: %.5e\\n', err);\n</code></pre>"},{"location":"Non_Linear_Equations/Fixed_Point/","title":"Fixed Point Iteration","text":""},{"location":"Non_Linear_Equations/Newton/","title":"Newton's Method","text":""},{"location":"ODEs/Euler/","title":"Euler's","text":""},{"location":"ODEs/Euler/#explicit-euler","title":"Explicit Euler","text":""},{"location":"ODEs/Euler/#implicit-euler","title":"Implicit Euler","text":""},{"location":"ODEs/RungeKutta/","title":"Runge Kutta (Heun's Method)","text":"<p>format short e</p> <p>x0 = 2; % Interval starting point xN = 3; % Interval ending point y0 = 1; % initial condition N = 8; % sub-intervals</p> <p>Then, I define the step size</p> <pre><code>% step\nh = (xN - x0) / N;\n</code></pre> <pre><code>% Inizializzo x e y, e prealloco\nx = (x0:h:xN)'; % Note: it's a row vector\ny = zeros(N+1, 1);\ny(1) = y0;\n</code></pre> <p>% Function handle per f(x, y) f = @(x, y) (x . y) ./ ((x - 1).^2);  % This \"x.y\" vector product is the reason why we put x as % a row vector</p> <p>% Heun's method for n = 1:N     K1 = f(x(n), y(n));     K2 = f(x(n) + h, y(n) + h * K1);     y(n+1) = y(n) + (h / 2) * (K1 + K2); end</p> <p>% Exact solution y_exact = @(x) (x-1).*exp((x - 2) ./ (x - 1));</p> <p>% Vettore deglie errori e il massimo di questo vettore error = abs(y(end) - y_exact(3));</p>"},{"location":"ODEs/Trapezoid/","title":"Trapezoid Method","text":""}]}